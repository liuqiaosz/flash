<?xml version="1.0" encoding="utf-8"?>
<ui:AdvanceWindow xmlns:fx="http://ns.adobe.com/mxml/2009" 
				  xmlns:s="library://ns.adobe.com/flex/spark" 
				  xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:ui="editor.uitility.ui.*" width="800" height="600" dragEnter="dragImageOver(event)" dragDrop="dragImageDrop(event)" xmlns:local="*">
	<ui:layout>
		<s:VerticalLayout horizontalAlign="center" />
	</ui:layout>
	
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
	</fx:Declarations>
	
	
	
	<fx:Script>
		<![CDATA[
			import editor.uitility.ui.PopUpWindowManager;
			import editor.uitility.ui.event.PixelEditorEvent;
			
			import flash.display3D.textures.Texture;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.core.IUIComponent;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.ListEvent;
			import mx.managers.DragManager;
			
			import pixel.texture.PixelTextureEncodeEmu;
			import pixel.texture.PixelTextureFactory;
			import pixel.texture.vo.PixelTexture;
			import pixel.texture.vo.PixelTexturePackage;
			import pixel.tools.texture.event.TextureToolEvent;
			import pixel.tools.texture.utils.TextureEncoder;
			import pixel.utility.BitmapTools;
			import pixel.utility.ColorCode;
			
			import spark.events.IndexChangeEvent;
			
			[Bindable]
			private var image:BitmapData = null;
			[Bindable]
			private var imageWidth:int = 0;
			[Bindable]
			private var imageHeight:int = 0;
			[Bindable]
			private var textureId:String = "";
			[Bindable]
			private var editEnabled:Boolean = false;
			[Bindable]
			private var list:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var changeApply:Boolean = false;
			[Bindable]
			private var encoderApply:Boolean = false;
			[Bindable]
			private var encoderQuality:Boolean = false;
			[Bindable]
			private var finalSize:int = 0;
			
			public function textureWithFile(nav:String):void
			{
				var tpk:File = new File(nav);
				if(tpk.exists && tpk.extension == "tpk")
				{
					var reader:FileStream = new FileStream();
					reader.open(tpk,FileMode.READ);
					var data:ByteArray = new ByteArray();
					reader.readBytes(data,0,reader.bytesAvailable);
					data.position = 0;
					var pack:PixelTexturePackage = PixelTextureFactory.instance.decode(data);
					//pack.decode(data);
					reader.close();
					var textures:Vector.<PixelTexture> = pack.textures;
					for each(var texture:PixelTexture in textures)
					{
						list.addItem(texture);
					}
				}
			}

			
			protected function encodeTexture(pixels:ByteArray):void
			{
				var loader:Loader = new Loader();
				loader.contentLoaderInfo.addEventListener(Event.COMPLETE,function(event:Event):void{
					image = Bitmap(loader.content).bitmapData;
					imageWidth = image.width;
					imageHeight = image.height;
				});
				loader.loadBytes(pixels);
			}
			
			protected function dragImageOver(event:DragEvent):void
			{
				DragManager.acceptDragDrop(event.currentTarget as IUIComponent);
			}
			
			private var _queue:Vector.<File> = new Vector.<File>();
			protected function dragImageDrop(event:DragEvent):void
			{
				_queue.length = 0;
				var files:Array = event.dragSource.dataForFormat(ClipboardFormats.FILE_LIST_FORMAT) as Array;
				var file:File = null;
				for each(file in files)
				{
					if(file.extension == "png" || file.extension == "jpeg" || file.extension == "jpg")
					{
						_queue.push(file);
					}
				}
				if(_queue.length > 0)
				{
					_loader = new Loader();
					_loader.contentLoaderInfo.addEventListener(Event.COMPLETE,loadComplete);
					loadImage();
				}
			}
			
			private function loadComplete(event:Event):void
			{
				var img:Bitmap = _loader.content as Bitmap;
				
				var image:BitmapData = new BitmapData(img.width,img.height);
				var source:ByteArray = img.bitmapData.getPixels(img.bitmapData.rect);
				source.position = 0;
				image.setPixels(image.rect,source);
				
				var pixels:ByteArray = image.getPixels(image.rect);
				
				//pixels.compress(CompressionAlgorithm.LZMA);
				pixels.position = 0;
				var texture:PixelTexture = new PixelTexture(pixels);
				texture.imageWidth = image.width;
				texture.imageHeight = image.height;
				texture.id = "" + list.length;
				list.addItem(texture);
				texture.bitmap;
				loadImage();
			}
			
			private var _currentFile:File = null;
			private var _loader:Loader = null;
			protected function loadImage():void
			{
				if(_queue.length > 0)
				{
					_currentFile = _queue.shift();
					var reader:FileStream = new FileStream();
					reader.open(_currentFile,FileMode.READ);
					var source:ByteArray = new ByteArray();
					reader.readBytes(source,0,reader.bytesAvailable);
					_loader.loadBytes(source);
					//_loader.load(new URLRequest(_queue.shift()));
				}
				else
				{
					if(_loader)
					{
						_loader.removeEventListener(Event.COMPLETE,loadComplete);
						_loader.unload();
						_loader = null;
					}
				}
			}
			
			private var selectItem:PixelTexture = null;
			protected function textureSelected(event:ListEvent):void
			{
				editEnabled = true;
				selectItem = list.getItemAt(event.rowIndex) as PixelTexture;
				texturePropertie.texture = selectItem;
				textureId = selectItem.id;
			}

			
			private function updatePreview(event:TextureToolEvent):void
			{
				changeApply = true;
				var _texture:PixelTexture = texturePropertie.texture;
				var source:BitmapData = BitmapTools.BitmapClone(texturePropertie.texture.bitmap);
				if(_texture.alphaCut)
				{
					source = BitmapTools.CutAlpha(source);
					
				}
				
				var pixels:ByteArray = source.getPixels(source.rect);
				finalSize = pixels.length / 1024;
				var compressPixels:ByteArray = null;
				
				if(_texture.encoderEnabled)
				{
					switch(_texture.encoder)
					{
						case PixelTextureEncodeEmu.ENCODER_API:
							var encoded:ByteArray = new ByteArray();
							source.encode(source.rect,PixelTextureEncodeEmu.getEncoder(_texture.encodeType,_texture.encodeQuality),encoded);
							this.encodeTexture(encoded);
							finalSize = encoded.length / 1024;
							break;
						case PixelTextureEncodeEmu.ENCODER_PIXEL:
							switch(_texture.pixelCompressOp)
							{
								case PixelTextureEncodeEmu.PIXELENCODE_ARGB4444:
									compressPixels = BitmapTools.pixelsCompressToARGB4444(pixels);
									pixels = BitmapTools.pixelsUncompressARGB4444ToARGB8888(compressPixels,false);
									break;
								case PixelTextureEncodeEmu.PIXELENCODE_RGB565:
									compressPixels = BitmapTools.pixelsCompressToRGB565(pixels);
									pixels = BitmapTools.pixelsUncompressRGB565ToRGB888(compressPixels,false);
									break;
							}
							pixels.position = 0;
							source.setPixels(source.rect,pixels);
							
							compressPixels.compress(CompressionAlgorithm.LZMA);
							finalSize = compressPixels.length / 1024;
							break;
					}
				}
				image = source;
				imageWidth = image.width;
				imageHeight = image.height;

			}

			protected function saveFile():void
			{
				var window:TexturePackageSaveDialog = PopUpWindowManager.PopUp(TexturePackageSaveDialog) as TexturePackageSaveDialog;
				window.addEventListener(TextureToolEvent.TEXTURE_SAVETPK,function(event:TextureToolEvent):void{
					var path:String = event.value as String;
					if(path.indexOf(".tpk") < 0)
					{
						path += ".tpk";
					}
					
					var pack:PixelTexturePackage = new PixelTexturePackage();
					pack.isAnim = window.isTextureAnim;
					if(pack.isAnim)
					{
						pack.playGap = window.animPlayGap;
					}
					var file:File = new File(path);
					for each(var texture:PixelTexture in list)
					{
						TextureEncoder.textureEncode(texture);
						pack.addTexture(texture);
					}
					var data:ByteArray = PixelTextureFactory.instance.encode(pack);
					var writer:FileStream = new FileStream();
					writer.open(file,FileMode.WRITE);
					writer.writeBytes(data);
					writer.close();
				});
//				var browser:File = new File();
//				browser.addEventListener(Event.SELECT,function(fileEvent:Event):void{
//					var path:String = browser.nativePath + ".tpk";
//					var pack:PixelTexturePackage = new PixelTexturePackage();
//					var file:File = new File(path);
//					for each(var texture:PixelTexture in list)
//					{
//						TextureEncoder.textureEncode(texture);
//						pack.addTexture(texture);
//					}
//					var data:ByteArray = PixelTextureFactory.instance.encode(pack);
//					var writer:FileStream = new FileStream();
//					writer.open(file,FileMode.WRITE);
//					writer.writeBytes(data);
//					writer.close();
//				});
//				
//				browser.browseForSave("选择保存路径");
			}

			private static const MENU_BATCH:int = 0;
			private static const MENU_BATCH_SAVEIMG:int = 1;//批量保存当前列表资源为图片
			private static const MENU_BATCH_ENCODE:int = 2;//批量选择当前列表的编码方式
			private static const MENU_SAVETPK:int = 40;//将当前列表的资源保存成TPK文件
			[Bindable]
			private var menuData:Array = [
				{
					label: "文件",
					children: [
						{
							id: MENU_BATCH,
							label: "批处理",
							children :[
								{
									id: MENU_BATCH_SAVEIMG,
									label: "批量保存图片"
								},
								{
									id: MENU_BATCH_ENCODE,
									label: "图片批量编码"
								}
							]
						},
						{
							id: MENU_SAVETPK,
							label: "保存TPK"
						}
					]
				}
			];
			
			protected function menuSelected(event:PixelEditorEvent):void
			{
				var id:int = event.value as int;
				switch(id)
				{
					case MENU_SAVETPK:
						saveFile();
						break;
					case MENU_BATCH_SAVEIMG:
						batchImageSave();
						break;
					case MENU_BATCH_ENCODE:
						batchEncodeOpen();
						break;
						
//					case RES_PACK_NEW:
//						PopUpWindowManager.PopUp(TexturePackageWindow);
//						break;
//					case RES_PACK_OPEN:
//						openTexturePackage();
//						break;
				}
			}
			
			/**
			 * 将当前纹理列表的资源批量保存在用户选择的目录，文件名按照ID命名
			 * 
			 **/
			private function batchImageSave():void
			{
				var browser:File = new File();
				browser.addEventListener(Event.SELECT,function(fileEvent:Event):void{
					var path:String = browser.nativePath;
//					var pack:PixelTexturePackage = new PixelTexturePackage();
//					var file:File = new File(path);
//					for each(var texture:PixelTexture in list)
//					{
//						pack.addTexture(texture);
//					}
//					var data:ByteArray = PixelTextureFactory.instance.encode(pack);
//					var writer:FileStream = new FileStream();
//					writer.open(file,FileMode.WRITE);
//					writer.writeBytes(data);
//					writer.close();
					var prefix:String = "";
					var writer:FileStream = new FileStream();
					for(var idx:int = 0; idx<list.length; idx++)
					{
						var texture:PixelTexture = list.getItemAt(idx) as PixelTexture;
						if(texture.encoder == PixelTextureEncodeEmu.ENCODER_API)
						{
							switch(texture.encodeType)
							{
//								case PixelTextureEncodeEmu.ENCODE_JPGXR:
//									prefix = "jpg";
//									break;
								case PixelTextureEncodeEmu.ENCODE_JPG:
									prefix = "jpg";
									break;
								case PixelTextureEncodeEmu.ENCODE_PNG:
									prefix = "png";
									break;
								default:
									
									continue;
							}
							
							var nav:String = path + "/" + texture.id + "." + prefix;
							var img:File = new File(nav);
							writer.open(img,FileMode.WRITE);
							writer.writeBytes(texture.source);
							writer.close();
						}
						
					}
				});
				browser.browseForDirectory("请选择图片保存路径");
			}
			
			private function batchEncodeOpen():void
			{
				var window:TextureBatchPropertie = PopUpWindowManager.PopUp(TextureBatchPropertie) as TextureBatchPropertie;
				window.addEventListener(TextureToolEvent.TEXTURE_APPLYENCODE,batchEncodeApply);
			}
			
			private function batchEncodeApply(event:TextureToolEvent):void
			{
				var _texture:PixelTexture = event.value as PixelTexture;
				var item:PixelTexture = null;
				for(var idx:int = 0; idx<list.length; idx++)
				{
					item = list.getItemAt(idx) as PixelTexture;
					item.alphaCut = _texture.alphaCut;
					item.encodeQuality = _texture.encodeQuality;
					item.encoder = _texture.encoder;
					item.encoderEnabled = _texture.encoderEnabled;
					item.encodeType = _texture.encodeType;
					item.pixelCompressOp = _texture.pixelCompressOp;
					//TextureEncoder.textureEncode(item);
				}
			}
		]]>
		
	</fx:Script>
	<ui:AdvanceMenuBar width="100%" id="mainMenu" MenuSelected="menuSelected(event)" dataProvider="{menuData}" />
	<s:HGroup width="780" height="100%" gap="5">
		<s:VGroup height="100%">
			<mx:Tree height="100%" width="100%" labelField="id" dataProvider="{list}" itemClick="textureSelected(event)" />
			<s:Scroller width="100%" height="100%">
				<s:VGroup height="100%" gap="10" enabled="{editEnabled}">
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="宽度" />
						<s:Label text="{imageWidth}" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="高度" />
						<s:Label text="{imageHeight}" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="纹理大小" />
						<s:Label text="{finalSize}" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="ID" />
						<s:TextInput width="150" restrict="0-9 a-z A-Z" text="{textureId}" id="pixelTextureId" />
					</s:HGroup>
					
					<local:TexturePropertie width="100%" height="100%" id="texturePropertie" UpdatePreview="updatePreview(event)" />
					<!--
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="透明剪裁" />
						<s:CheckBox selected="{alphaCut}" id="alphaCutCheck" change="alphaCutChanged(event)" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="编码方式" />
						<s:ComboBox dataProvider="{COMPRESS_OPTION}" change="encoderOptionChanged(event)" id="encoderType" />
					</s:HGroup>
					<s:HGroup verticalAlign="middle" visible="{encoderApply}" includeInLayout="{encoderApply}">
						<s:Label width="100" text="编码器" />
						<s:ComboBox id="encoder" dataProvider="{ENCODER}" change="encoderChanged(event)" selectedIndex="0"/>
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle" visible="{encoderQuality}" includeInLayout="{encoderQuality}">
						<s:Label width="100" text="编码质量" />
						<s:ComboBox id="encodeQuality" dataProvider="{ENCODE_QUALITY}" change="encodeQulityChanged(event)" selectedIndex="0" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle" visible="{pixelCompress}" includeInLayout="{pixelCompress}">
						<s:Label width="100" text="编码选项" />
						<s:ComboBox dataProvider="{PIXEL_COMPRESS_OPTION}" id="pixelOption" change="pixelCompressChanged(event)" selectedIndex="0"/>
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="像素有损编码" />
						<s:CheckBox selected="{pixelCompress}" id="pixelCompressCheck" change="pixelCompressChecked(event)"/>
					</s:HGroup>
					
					
					<s:HGroup verticalAlign="middle">
					<s:Label width="100" text="定义注册点" />
					<s:CheckBox selected="{customAnchor}"/>
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle" width="100%">
						<s:Button width="100%" label="保存修改" enabled="{changeApply}" click="save(event)" />
						
					</s:HGroup>
					-->
				</s:VGroup>
			</s:Scroller>
		</s:VGroup>
		
		<s:VGroup height="100%" width="100%" gap="5" enabled="{editEnabled}">
			<s:BorderContainer width="100%" height="100%">
				<s:Scroller id="scroller" width="100%" height="100%">
					<s:Group>
						<s:Rect id="editBackground" width="100%" height="100%">
							<s:fill>
								<s:BitmapFill source="@Embed('Grid.png')" fillMode="repeat"  />
							</s:fill>
						</s:Rect>
						<s:Image source="{image}" smooth="true" smoothingQuality="high" id="preview" />
					</s:Group>
				</s:Scroller>
			</s:BorderContainer>
		</s:VGroup>
	</s:HGroup>
	
</ui:AdvanceWindow>
