<?xml version="1.0" encoding="utf-8"?>
<ui:AdvanceWindow xmlns:fx="http://ns.adobe.com/mxml/2009" 
				  xmlns:s="library://ns.adobe.com/flex/spark" 
				  xmlns:mx="library://ns.adobe.com/flex/mx" xmlns:ui="editor.uitility.ui.*" width="800" height="600" dragEnter="dragImageOver(event)" dragDrop="dragImageDrop(event)">
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
	</fx:Declarations>
	
	
	
	<fx:Script>
		<![CDATA[
			import editor.uitility.ui.event.PixelEditorEvent;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.core.IUIComponent;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.ListEvent;
			import mx.managers.DragManager;
			
			import pixel.texture.PixelTextureEncodeEmu;
			import pixel.texture.PixelTextureFactory;
			import pixel.texture.vo.PixelTexture;
			import pixel.texture.vo.PixelTexturePackage;
			import pixel.utility.BitmapTools;
			import pixel.utility.ColorCode;
			
			import spark.events.IndexChangeEvent;
			
			[Bindable]
			private static var PIXEL_COMPRESS_OPTION:ArrayCollection = new ArrayCollection([
				
				{
					label : "ARGB4444",
					value : PixelTextureEncodeEmu.PIXELENCODE_ARGB4444
				},
//				{
//					label : "RGB555",
//					value : PixelCompressOption.COMPRESS_RGB555
//				},
				{
					label : "RGB565",
					value : PixelTextureEncodeEmu.PIXELENCODE_RGB565
				},
//				{
//					label : "ARGB1555",
//					value : PixelCompressOption.COMPRESS_ARGB1555
//				}
			]);

			[Bindable]
			private static var ENCODER:ArrayCollection = new ArrayCollection([
				{
					label : "JPG",
					value : PixelTextureEncodeEmu.ENCODE_JPG
				},
				{
					label : "PNG",
					value : PixelTextureEncodeEmu.ENCODE_PNG
				},
				{
					label : "JPG-XR",
					value : PixelTextureEncodeEmu.ENCODE_JPGXR
				}
			]);
			
			[Bindable]
			private static var ENCODE_QUALITY:ArrayCollection = new ArrayCollection([
				
				{
					label : "高",
					value : PixelTextureEncodeEmu.QUALITY_HIGHT
				},
				{
					label : "中",
					value : PixelTextureEncodeEmu.QUALITY_MID
				},
				{
					label : "低",
					value : PixelTextureEncodeEmu.QUALITY_LOW
				}
			
			]);
			
			[Bindable]
			private static var COMPRESS_OPTION:ArrayCollection = new ArrayCollection([
				{
					label : "API图形编码",
					value : PixelTextureEncodeEmu.ENCODER_API
				},
				{
					label : "像素有损编码",
					value : PixelTextureEncodeEmu.ENCODER_PIXEL
				}
			]);
			
			[Bindable]
			private var image:BitmapData = null;
			[Bindable]
			private var imageWidth:int = 0;
			[Bindable]
			private var imageHeight:int = 0;
			[Bindable]
			private var textureId:String = "";
			[Bindable]
			private var editEnabled:Boolean = false;
			[Bindable]
			private var alphaCut:Boolean = false;
			//[Bindable]
			//private var compress:Boolean = false;
			[Bindable]
			private var pixelCompress:Boolean = false;
			[Bindable]
			private var customAnchor:Boolean = false;
			[Bindable]
			private var _texture:PixelTexture = null;
			[Bindable]
			private var list:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var changeApply:Boolean = false;
			[Bindable]
			private var encoderApply:Boolean = false;
			[Bindable]
			private var encoderQuality:Boolean = false;
			[Bindable]
			private var finalSize:int = 0;
			
			public function textureWithFile(nav:String):void
			{
				var tpk:File = new File(nav);
				if(tpk.exists && tpk.extension == "tpk")
				{
					var reader:FileStream = new FileStream();
					reader.open(tpk,FileMode.READ);
					var data:ByteArray = new ByteArray();
					reader.readBytes(data,0,reader.bytesAvailable);
					data.position = 0;
					var pack:PixelTexturePackage = PixelTextureFactory.instance.decode(data);
					//pack.decode(data);
					reader.close();
					var textures:Vector.<PixelTexture> = pack.textures;
					for each(var texture:PixelTexture in textures)
					{
						list.addItem(texture);
					}
				}
			}
			
			protected function set texture(value:PixelTexture):void
			{
				if(value)
				{
					var idx:int = 0;
					var item:Object = null;
					editEnabled = true;
					_texture = value;
					alphaCut = _texture.alphaCut;
					finalSize = _texture.source.length / 1024;
					
					encoder.selectedIndex = 0;
					encodeQuality.selectedIndex = 0;
					pixelOption.selectedIndex = 0;
					encoderType.selectedIndex = -1;
					encoderQuality = encoderApply = false;
					pixelCompress = false;
					if(_texture.encoderEnabled)
					{
						switch(_texture.encoder)
						{
							case PixelTextureEncodeEmu.ENCODER_API:
								encoderQuality = encoderApply = true;
								encoderType.selectedIndex = 0;
								//编码器类型
								for(idx = 0; idx<ENCODER.length; idx++)
								{
									item = ENCODER[idx];
									if(item.value == _texture.encodeType)
									{
										encoder.selectedItem = item;
									}
								}
								if(_texture.encodeType == PixelTextureEncodeEmu.ENCODE_JPG || _texture.encodeType == PixelTextureEncodeEmu.ENCODE_JPGXR)
								{
									encoderQuality = true;
									//编码器质量
									for(idx = 0; idx<ENCODE_QUALITY.length; idx++)
									{
										item = ENCODE_QUALITY[idx];
										if(item.value == _texture.encodeQuality)
										{
											encodeQuality.selectedItem = item;
										}
									}
								}
								//encodeTexture(_texture.source);
								//image = _texture.bitmap;
								break;
							case PixelTextureEncodeEmu.ENCODER_PIXEL:
								encoderType.selectedIndex = 1;
								pixelCompress = true;
								for(idx = 0; idx<PIXEL_COMPRESS_OPTION.length; idx++)
								{
									item = PIXEL_COMPRESS_OPTION.getItemAt(idx);
									if(item.value == _texture.pixelCompressOp)
									{
										pixelOption.selectedItem = item;
									}
								}
								//image = _texture.bitmap;
								break;
						}
					}
					image = _texture.bitmap;
					customAnchor = _texture.customAnchor;
					if(image)
					{
						imageWidth = image.width;
						imageHeight = image.height;
					}
					
					textureId = _texture.id;
					changeApply = false;
				}
			}
			
			protected function encodeTexture(pixels:ByteArray):void
			{
				var loader:Loader = new Loader();
				loader.contentLoaderInfo.addEventListener(Event.COMPLETE,function(event:Event):void{
					image = Bitmap(loader.content).bitmapData;
					imageWidth = image.width;
					imageHeight = image.height;
				});
				loader.loadBytes(pixels);
			}
			
			protected function dragImageOver(event:DragEvent):void
			{
				DragManager.acceptDragDrop(event.currentTarget as IUIComponent);
			}
			
			private var _queue:Vector.<String> = new Vector.<String>();
			protected function dragImageDrop(event:DragEvent):void
			{
				_queue.length = 0;
				var files:Array = event.dragSource.dataForFormat(ClipboardFormats.FILE_LIST_FORMAT) as Array;
				var file:File = null;
				for each(file in files)
				{
					if(file.extension == "png" || file.extension == "jpeg" || file.extension == "jpg")
					{
						_queue.push(file.nativePath);
					}
				}
				if(_queue.length > 0)
				{
					_loader = new Loader();
					_loader.contentLoaderInfo.addEventListener(Event.COMPLETE,loadComplete);
					loadImage();
				}
			}
			
			private function loadComplete(event:Event):void
			{
				var img:Bitmap = _loader.content as Bitmap;
				
				var image:BitmapData = new BitmapData(img.width,img.height);
				var source:ByteArray = img.bitmapData.getPixels(img.bitmapData.rect);
				source.position = 0;
				image.setPixels(image.rect,source);
				
				var pixels:ByteArray = image.getPixels(image.rect);
				
				//pixels.compress(CompressionAlgorithm.LZMA);
				pixels.position = 0;
				var texture:PixelTexture = new PixelTexture(pixels);
				texture.imageWidth = image.width;
				texture.imageHeight = image.height;
				texture.id = "" + list.length;
				list.addItem(texture);
				loadImage();
			}
			
			private var _loader:Loader = null;
			protected function loadImage():void
			{
				if(_queue.length > 0)
				{
					var f:File = new File(_queue.shift());
					var r:FileStream = new FileStream();
					r.open(f,FileMode.READ);
					var d:ByteArray = new ByteArray();
					r.readBytes(d,0,r.bytesAvailable);
					
					var l:Loader = new Loader();
					l.contentLoaderInfo.addEventListener(Event.COMPLETE,function(event:Event):void{
						trace("!!");
					});
					l.loadBytes(d);
					//_loader.load(new URLRequest(_queue.shift()));
				}
				else
				{
					if(_loader)
					{
						_loader.removeEventListener(Event.COMPLETE,loadComplete);
						_loader.unload();
						_loader = null;
					}
				}
			}
			
			private var selectItem:PixelTexture = null;
			protected function textureSelected(event:ListEvent):void
			{
				selectItem = list.getItemAt(event.rowIndex) as PixelTexture;
				if(selectItem == _texture)
				{
					return;
				}
				if(changeApply)
				{
					Alert.show("未保存的修改","",Alert.YES | Alert.CANCEL,null,function(close:CloseEvent):void{
						
						if(close.detail == Alert.YES)
						{
							saveCurrentChanged();
							
						}
						changeApply = false;
						texture = selectItem;
					});
				}
				else
				{
					texture = selectItem;
				}
			}
			
			private function saveCurrentChanged():void
			{
				//_texture.alphaCut = alphaCut;
				//_texture.bitmap = image;
				//_texture.compress = compress;
				var source:BitmapData = BitmapTools.BitmapClone(_texture.bitmap);
				//var pixels:ByteArray = _texture.bitmap.getPixels(_texture.bitmap.rect);
				//_texture.id = pixelTextureId.text;
				var compressPixels:ByteArray = null;
				var pixels:ByteArray = null;
				if(_texture.encoderEnabled)
				{
					switch(_texture.encoder)
					{
						case PixelTextureEncodeEmu.ENCODER_API:
							pixels = new ByteArray();
							source.encode(source.rect,PixelTextureEncodeEmu.getEncoder(_texture.encodeType,_texture.encodeQuality),pixels);
							break;
						case PixelTextureEncodeEmu.ENCODER_PIXEL:
							switch(_texture.pixelCompressOp)
							{
								case PixelTextureEncodeEmu.PIXELENCODE_ARGB4444:
									pixels = BitmapTools.pixelsCompressToARGB4444(pixels);
									//pixels = BitmapTools.pixelsUncompressARGB4444ToARGB8888(compressPixels,false);
									break;
								case PixelTextureEncodeEmu.PIXELENCODE_RGB565:
									pixels = BitmapTools.pixelsCompressToRGB565(pixels);
									//pixels = BitmapTools.pixelsUncompressRGB565ToRGB888(compressPixels,false);
									break;
							}
							break;
					}
				}
				_texture.source = pixels;
				changeApply = false;
			}
			
			private function updatePreview():void
			{
				changeApply = true;
				var source:BitmapData = BitmapTools.BitmapClone(_texture.bitmap);
				if(alphaCut)
				{
					source = BitmapTools.CutAlpha(source);
					
				}
				
				var pixels:ByteArray = source.getPixels(source.rect);
				finalSize = pixels.length / 1024;
				var compressPixels:ByteArray = null;
				
				if(_texture.encoderEnabled)
				{
					switch(_texture.encoder)
					{
						case PixelTextureEncodeEmu.ENCODER_API:
							var encoded:ByteArray = new ByteArray();
							source.encode(source.rect,PixelTextureEncodeEmu.getEncoder(_texture.encodeType,_texture.encodeQuality),encoded);
							this.encodeTexture(encoded);
							finalSize = encoded.length / 1024;
							break;
						case PixelTextureEncodeEmu.ENCODER_PIXEL:
							switch(_texture.pixelCompressOp)
							{
								case PixelTextureEncodeEmu.PIXELENCODE_ARGB4444:
									compressPixels = BitmapTools.pixelsCompressToARGB4444(pixels);
									pixels = BitmapTools.pixelsUncompressARGB4444ToARGB8888(compressPixels,false);
									break;
								case PixelTextureEncodeEmu.PIXELENCODE_RGB565:
									compressPixels = BitmapTools.pixelsCompressToRGB565(pixels);
									pixels = BitmapTools.pixelsUncompressRGB565ToRGB888(compressPixels,false);
									break;
							}
							pixels.position = 0;
							source.setPixels(source.rect,pixels);
							
							compressPixels.compress(CompressionAlgorithm.LZMA);
							finalSize = compressPixels.length / 1024;
							break;
					}
				}
				image = source;
				imageWidth = image.width;
				imageHeight = image.height;
//				if(pixelCompress)
//				{
//					var op:Object = PIXEL_COMPRESS_OPTION.getItemAt(pixelOption.selectedIndex);
//					switch(op.value)
//					{
//						case PixelTextureEncodeEmu.PIXELENCODE_ARGB4444:
//							compressPixels = BitmapTools.pixelsCompressToARGB4444(pixels);
//							pixels = BitmapTools.pixelsUncompressARGB4444ToARGB8888(compressPixels,false);
//							break;
//						case PixelTextureEncodeEmu.PIXELENCODE_RGB565:
//							compressPixels = BitmapTools.pixelsCompressToRGB565(pixels);
//							pixels = BitmapTools.pixelsUncompressRGB565ToRGB888(compressPixels,false);
////							pixels.position = 0;
////							var jpg:BitmapData = new BitmapData(source.width,source.height);
////							jpg.setPixels(jpg.rect,pixels);
////							var d:ByteArray = new ByteArray();
////							jpg.encode(jpg.rect,new JPEGXREncoderOptions(),d);
////							d.position = 0;
////							
////							var loa:Loader = new Loader();
////							loa.contentLoaderInfo.addEventListener(Event.COMPLETE,function(event:Event):void{
////								
////								var im:Bitmap = loa.content as Bitmap;
////							});
////							loa.loadBytes(d);
////							
//							break;
//					}
//					
//					
//					pixels.position = 0;
//					source.setPixels(source.rect,pixels);
//				}
				
//				if(encoderApply)
//				{
//					//_texture.encodeType = encoder.selectedItem.value;
//					//_texture.encodeQuality = encodeQuality.selectedItem.value;
//					var encoded:ByteArray = new ByteArray();
//					source.encode(source.rect,PixelTextureEncodeEmu.getEncoder(_texture.encodeType,_texture.encodeQuality),encoded);
//					//pixels = encoded;
//					this.encodeTexture(encoded);
//					finalSize = encoded.length / 1024;
//				} 
//				else
//				{
//					image = source;
//
//					compressPixels.compress(CompressionAlgorithm.LZMA);
//					finalSize = compressPixels.length / 1024;
//				}
			}
			
			protected function pixelCompressChanged(event:IndexChangeEvent):void
			{
				var value:int = PIXEL_COMPRESS_OPTION[event.newIndex].value;
				_texture.pixelCompressOp = value;
				updatePreview();
			}
			
//			protected function pixelCompressChecked(event:Event):void
//			{
//				pixelCompress = pixelCompressCheck.selected;
//				pixelOption.selectedIndex = -1;
//			}
			
			protected function save(event:MouseEvent):void
			{
				saveCurrentChanged();
			}
			
			protected function saveFile(event:MouseEvent):void
			{
				var browser:File = new File();
				browser.addEventListener(Event.SELECT,function(fileEvent:Event):void{
					var path:String = browser.nativePath + ".tpk";
					var pack:PixelTexturePackage = new PixelTexturePackage();
					var file:File = new File(path);
					for each(var texture:PixelTexture in list)
					{
						pack.addTexture(texture);
					}
					var data:ByteArray = PixelTextureFactory.instance.encode(pack);
					var writer:FileStream = new FileStream();
					writer.open(file,FileMode.WRITE);
					writer.writeBytes(data);
					writer.close();
				});
				
				browser.browseForSave("选择保存路径");
			}
			
			protected function encoderChanged(event:IndexChangeEvent):void
			{
				//compress = compressCheck.selected;
				//_texture.compress = compress;
				_texture.encodeType = ENCODER[event.newIndex].value;
				_texture.encodeQuality =  PixelTextureEncodeEmu.QUALITY_HIGHT;
				encodeQuality.selectedIndex = 0;
				encoderQuality = (_texture.encodeType == PixelTextureEncodeEmu.ENCODE_JPG || _texture.encodeType == PixelTextureEncodeEmu.ENCODE_JPGXR);
				updatePreview();
			}
			
//			protected function encoderEnabled(event:Event):void
//			{
//				encoderQuality = encoderApply = encoderSwitch.selected;
//			}
			
			protected function encodeQulityChanged(event:IndexChangeEvent):void
			{
				var value:int = ENCODE_QUALITY.getItemAt(event.newIndex).value;
				_texture.encodeQuality = value;
				updatePreview();
			}
			
			protected function encoderOptionChanged(event:IndexChangeEvent):void
			{
				var value:int = COMPRESS_OPTION[event.newIndex].value;
				_texture.encoderEnabled = true;
				_texture.encoder = value;
				switch(value)
				{
					case PixelTextureEncodeEmu.ENCODER_API:
						encoderQuality = encoderApply = true;
						_texture.encodeQuality = encodeQuality.selectedItem.value;
						_texture.encodeType = encoder.selectedItem.value;
						pixelCompress = false;
						pixelOption.selectedIndex = -1;
						break;
					case PixelTextureEncodeEmu.ENCODER_PIXEL:
						encoderQuality = encoderApply = false;
						pixelCompress = true;
						pixelOption.selectedIndex = 0;
						_texture.pixelCompressOp = pixelOption.selectedItem.value;
						break;
					default:
						_texture.encoderEnabled = false;
						_texture.encoder = 0;
						break;
				}
				
				this.updatePreview();
			}
			
			protected function alphaCutChanged(event:Event):void
			{
				_texture.alphaCut = alphaCut = alphaCutCheck.selected;
				updatePreview();
			}
			
		]]>
	</fx:Script>
	
	<s:HGroup width="780" height="550" x="10" y="10" gap="5">
		<s:VGroup height="100%">
			<mx:Tree height="100%" width="100%" labelField="id" dataProvider="{list}" itemClick="textureSelected(event)" />
			<s:Scroller width="100%" height="100%">
				<s:VGroup height="100%" gap="10" enabled="{editEnabled}">
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="宽度" />
						<s:Label text="{imageWidth}" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="高度" />
						<s:Label text="{imageHeight}" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="纹理大小" />
						<s:Label text="{finalSize}" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="ID" />
						<s:TextInput width="150" restrict="0-9 a-z A-Z" text="{textureId}" id="pixelTextureId" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="透明剪裁" />
						<s:CheckBox selected="{alphaCut}" id="alphaCutCheck" change="alphaCutChanged(event)" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="编码方式" />
						<s:ComboBox dataProvider="{COMPRESS_OPTION}" change="encoderOptionChanged(event)" id="encoderType" />
					</s:HGroup>
					<s:HGroup verticalAlign="middle" visible="{encoderApply}" includeInLayout="{encoderApply}">
						<s:Label width="100" text="编码器" />
						<s:ComboBox id="encoder" dataProvider="{ENCODER}" change="encoderChanged(event)" selectedIndex="0"/>
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle" visible="{encoderQuality}" includeInLayout="{encoderQuality}">
						<s:Label width="100" text="编码质量" />
						<s:ComboBox id="encodeQuality" dataProvider="{ENCODE_QUALITY}" change="encodeQulityChanged(event)" selectedIndex="0" />
					</s:HGroup>
					
					<s:HGroup verticalAlign="middle" visible="{pixelCompress}" includeInLayout="{pixelCompress}">
						<s:Label width="100" text="编码选项" />
						<s:ComboBox dataProvider="{PIXEL_COMPRESS_OPTION}" id="pixelOption" change="pixelCompressChanged(event)" selectedIndex="0"/>
					</s:HGroup>
					<!--
					<s:HGroup verticalAlign="middle">
						<s:Label width="100" text="像素有损编码" />
						<s:CheckBox selected="{pixelCompress}" id="pixelCompressCheck" change="pixelCompressChecked(event)"/>
					</s:HGroup>
					
					
					<s:HGroup verticalAlign="middle">
					<s:Label width="100" text="定义注册点" />
					<s:CheckBox selected="{customAnchor}"/>
					</s:HGroup>
					-->
					<s:HGroup verticalAlign="middle" width="100%">
						<s:Button width="100%" label="保存修改" enabled="{changeApply}" click="save(event)" />
						<s:Button width="100%" label="文件保存" click="saveFile(event)" />
					</s:HGroup>
					
				</s:VGroup>
			</s:Scroller>
			
		</s:VGroup>
		
		<s:VGroup height="100%" width="100%" gap="5" enabled="{editEnabled}">
			<s:BorderContainer width="100%" height="100%">
				<s:Scroller id="scroller" width="100%" height="100%">
					<s:Group>
						<s:Rect id="editBackground" width="100%" height="100%">
							<s:fill>
								<s:BitmapFill source="@Embed('Grid.png')" fillMode="repeat"  />
							</s:fill>
						</s:Rect>
						<s:Image source="{image}" smooth="true" smoothingQuality="high" id="preview" />
					</s:Group>
				</s:Scroller>
			</s:BorderContainer>
		</s:VGroup>
	</s:HGroup>
	
</ui:AdvanceWindow>
